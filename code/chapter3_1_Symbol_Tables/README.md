# 3.1 符号表

**符号表**是一种存储键值对的数据结构，支持两种操作：

* **插入（put）**，即将一组新的键值对存入表中；
* **查找（get）**，即根据给定的键得到相应的值。

## API

符号表是一种典型的**抽象数据类型**。

实现遵循以下规则：

* 每个键只对应着一个值（表中**不允许存在重复的键**）。
* 当用例代码向表中存入的键值对和表中已有的键（及关联的值）**冲突**时，**新的值会替代旧的值**。
* 键不能为空。
* 值不能为空。这个规定是我们的 API 定义中当键不存在时`get()`方法会反悔空。

### 迭代

对于符号表，我们不使用`implements Iterable<Key>`来强制所有实现必须包含`iterator()`方法来返回一个实现了`hasNext()`和`next()`方法的迭代器，而是定义了`keys()`方法来返回一个`Iterable<Key>`对象以方便用例遍历所有的键。

## 有序符号表

许多符号表的实现都利用了 Comparable 接口带来的键的有序性来更好地实现`put()`和`get()`方法。

### 成本模型

在学习符号表的实现时，我们会统计**比较**的次数（等价性测试或是键的相互比较）。在内循环不进行比较（极少）的情况下，我们会统计**数组的访问次数**。

## 无序链表中的顺序查找

符号表中使用的数据结构的一个简单选择是链表，每个结点存储一个键值对。

在含有 N 对键值的基于（无序）链表的符号表中，未命中的查找和插入操作都需要 N 次比较。命中的查找在最坏情况下需要 N 次比较，特别地，向一个空表中插入 N 个不同的键需要 ~N^2/2 次比较。

## 有序数组中的二分查找

有序符号表的一种实现使用一对平行的数组，一个存储键一个存储值。这份实现的核心在于`rank()`方法，它返回表中小于给定键的键的数量（不管表中是否存在该键）。

## 对二分查找的分析

在 N 个键的**有序数组**中进行二分查找最多需要 (lgN+1) 次比较（无论是否成功）。

向大小为 N 的**有序数组**中插入一个新的元素在最坏情况下需要访问 ~2N 次数组，因此向一个空符号表中插入 N 个元素在最坏情况下需要访问 ~N^2 次数组。

## 预览

| 算法（数据结构） | N 次插入后最坏情况下的查找成本 | N 次插入后最坏情况下的插入成本 | N 次随机插入后平均情况下的查找成本 | N 次随机插入后平均情况下的查找成本 | 是否高效支持有序性相关的操作
| :----: | :----: | :----: | :----: | :----: | :----: |
| 顺序查找（无序链表） | N | N | N/2 | N | 否
| 二分查找（有序数组） | lgN | 2N | lgN | N | 是

现代应用需要**同时**能够支持高效的查找和插入两种操作的符号表实现。

为了将二分查找的效率和链表的灵活性结合起来，**二叉查找树**应运而生。

| 使用的数据结构 | 实现 | 优点 | 缺点
| :----: | :----: | :----: | :----: |
| 链表（顺序查找） | [SequentialSearchST]() | 适用于小型问题 | 对于大型符号表很慢
| 有序数组（二分查找） | [BinarySearchST]() | 最优的查找效率和空间需求，能够进行有序性相关的操作 | 插入操作很慢
| 二叉查找树 | [BST]() | 实现简单，能够进行有序性操作相关的操作 | 
| 平衡二叉查找树 | [RedBlackBST]() | 最优的查找和插入效率，能够进行有序性相关的操作 | 
| 散列表 | [SeparateChainHashST]()<p>[LinearProbingHashST]() | 能够快速地查找和插入常见类型的数据 | 



