# 3.4 散列表

使用散列的查找算法分为两步：

1. 使用**散列函数**将被查找的键转化为数组的一个索引；
2. **处理碰撞冲突**。

两种解决碰撞的方法：**拉链法**和**线性探测法**。

散列表是算法在**时间**和**空间**上做出权衡的经典例子，只需要调整散列算法的参数就可以在空间和时间之间做出取舍。使用散列表可以实现在一般应用中拥有（均摊后）**常数级别**的查找和插入操作的符号表。

## 散列函数

如果我们有一个能够保存 M 个键值对的数组，则需要能够将**任意键**转化为**该数组范围内的索引（[0, M-1] 范围内的整数）**的**散列函数**，这个散列函数应该**易于计算**并且能够**均匀分布**所有的键。

### 键为正整数

将**整数**散列的最常用方法是**除留余数法**：选择大小为**素数**（特别地，不是 2 的幂） M 的数组，对于任意正整数 k，计算 k 除以 M 的余数。

如果 M 不是素数，可能无法均匀地散列散列值。

### 键为浮点数

两种方法：

* 对于 0 到 1 之间的实数，可以乘以 M 并四舍五入得到一个 0 至 M-1 之间的索引值。但这种方式会使键的高位起的作用更大，最低位对散列的结果没有影响；
* 将键表示二进制数，然后使用除留余数法（Java 使用同样的方法）。

### 键为字符串

一种叫 Horner 方法的经典算法用 N 次乘法、加法和取余来计算一个字符串的散列值。

```java
int hash = 0;
for (int i = 0; i < s.length(); i++)
    hash = (R * hash + s.charAt(i)) % M;
```

只要 R 足够小，不造成溢出（这里我认为是指 int 类型的溢出），那么结果就能够落在 0 到 M-1 之内。

### 键为组合

可以用 String 类型一样的方法进行混合处理。例如对于由两个数字表示的 day、两个数字表示的 month、四个数字表示的 year 所构成的键类型 Date，可以这样计算散列值：

```java
int hash = (((day * R + month) % M) * R + year) % M;
```

### Java 的相关处理

Java 令所有数据类型都继承了一个能够返回一个 32 比特整数的`hashCode()`方法，且每一种数据类型的`hashCode()`方法都必须和`equals()`方法一致，即`a.equals(b) == true`说明`a.hashCode() == b.hashCode()`（但反过来不一定成立）。

如果要为自定义的数据类型定义散列函数，需要同时重写`hashCode()`和`equals()`两个方法。

### 将`hashCode()`的返回值转化为数组索引

因为需要的是数组索引而非一个 32 位的整数，在实现中会将默认的`hashCode()`方法和除留余数法结合产生一个 0 到 M-1 的整数：

```java
private int hash(Key k) {
    return (x.hashCode() & 0x7fffffff) % M;
}
```

这段代码会将符号位屏蔽（将一个 32 位整数变为一个 31 位非负整数），然后用除留余数法计算它除以 M 的余数。

### 软缓存

如果散列值的计算很耗时，可以考虑将**每个键的散列值缓存起来**，即在每个键中使用一个 hash 变量来保存它的`hashCode()`的返回值。

### 小结

总的来说，要为一个数据类型实现一个优秀的散列方法需要满足三个条件：

* 一致性：等价的键必然产生相等的散列值；
* 高效性：计算简便；
* 均匀性：均匀地散列所有的键。

其中，保证均匀性的最好方法是保证键的每一位都在散列值的计算中起到了相同的作用。

实现散列函数时有一个指导思想，称作**均匀散列假设**：我们使用的散列函数能够均匀并独立地将所有的键散布于 0 到 M-1 之间。这是一个实际无法达到的理想模型。

## 基于拉链法的散列表

**拉链法**：将大小为 M 的数组中的每个元素指向一条链表，链表中的每个结点都存储了散列值为该元素的索引的键值对。

查找分两步：首先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。

命题：在一张含有 M 条链表和 N 个键的散列表中，（在均匀散列假设成立的前提下）任意一条链表中的键的数量均在 N/M 的常数因子范围内的概率无限趋向于 1。

性质：在一张含有 M 条链表和 N 个键的散列表中，未命中查找和插入操作所需的比较次数为 ~N/M。

### 散列表的大小

选择适当的数组大小 M，既不会因为空链表而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。拉链法的一个**好处**是这并不是关键性的选择，对性能的影响没有那么大。

一种更可靠的方案是动态调整链表数组的大小，这样无论在符号表中有多少键值对都能保证链表较短。

### 有序性相关的操作

散列最主要的目的在于均匀地将键散布开来，因此在计算散列后键的顺序信息就丢失了。如果要执行有序性相关的操作，散列表不是最合适的选择，因为这些操作的运行时间都会是线性的。

## 基于线性探测法的散列表

实现散列表的另一种方式是用大小为 M 的数组保存 N 个键值对，其中 M > N，需要依靠数组中的**空位**解决碰撞冲突。基于这种策略的所有方法被统称为**开放地址**散列表，其中最简单的是**线性探测法**：当碰撞发生时（当一个键的散列值已经被另一个不同的键占用），直接检查散列表中的下一个位置（将索引值加 1）。这样的线性探测可能会产生三种结果：

* 命中，该位置的键和被查找的键相同；
* 未命中，键为空（该位置没有键）；
* 继续查找，该位置的键和被查找的键不同。

### 删除操作

实现删除操作时，直接将该键所在的位置设为 null 是不行的，因为这会使得在此位置之后的元素无法被查找。因此，我们需要将簇中被删除的右侧的所有键重新插入散列表。

和拉链法一样，开放地址类的散列表的性能也依赖于 a = N/M 的比值，但意义有所不同。我们将 a 称为散列表的**使用率**：

* 对于基于拉链法的散列表，a 是每条链表的长度，因此一般大于 1；
* 对于基于线性探测的散列表，a 是表中已被占用的空间的比例，不可能大于 1，且不允许达到 1（散列表被占满，未命中的查找会导致无限循环）。会动态调整保证使用率在 1/8 到 1/2 之间。

### 键簇

线性探测的平均成本取决于**元素在插入数组后聚集成的一组连续的条目**，也叫做**键簇**。短小的键簇才能保证较高的效率。

基于均匀散列假设，数组的每个位置都有相同的可能性被插入一个新键，长键簇更长的可能性比短键簇更大，因为新建的散列值无论落在簇中的任何位置都会使簇的长度加 1。

### 性能分析

在一张大小为 M 并含有 N = aM 个键的基于线性探测的散列表中，基于均匀散列假设，

* 命中的查找所需的探测次数为：~1/2 (1 + 1/(1 - a))
* 未命中的查找所需的探测次数为：~1/2 (1 + 1/(1 - a)^2)

## 调整数组大小

动态调整数组大小可以为我们保证 a 不大于 1/2。

* 对于拉链法，如果能够准确估计用例所需的散列表的大小 N，调整数组的工作不是必须的，选取一个适当的 M 即可；
* 对于线性探测法，调整数组的大小是必须的，因为当用例插入的键值对数量超过预期时，它的查找时间不仅会变得非常长，还会在散列表被填满时进入无限循环。

假设一张散列表能够自己调整数组的大小，初始为空。基于均匀散列假设，执行任意顺序的 t 次**查找**、**插入**和**删除**操作所需的时间和 t 成正比，所使用的内存量总是在表中的键的总数的常数因子范围内。

## 总结

### 符号表的内存使用

| 方法 | N 个元素所需的内存（引用类型） |
| :--: | :--: |
| 基于拉链法的散列表 | ~48N+32M |
| 基于线性探测的散列表 | 在 ~32N 和 ~128N 之间 |
| 各种二叉查找树 | ~56N |

### 散列表无法达到理论最优性能原因

* 每种类型的键都需要一个优秀的散列函数；
* 性能保证来自于散列函数的质量；
* 散列函数的计算可能复杂而且昂贵；
* 难以支持有序性相关的符号表操作。


