## 三种基础排序算法总结

### 验证

尽管一般都会测试代码并从数学上证明算法的正确性，但在实现每个排序算法时在测试代码中添加一条` isSorted(a);`来确认排序后数组元素都是有序的。

### 运行时间

**排序成本模型**：在研究排序算法时，我们需要计算**比较**和**交换**的数量。对于不交换元素的算法，我们会计算**访问数组的次数**。

### 额外的内存时间

排序算法可以分为两类：除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的**原地排序算法**，以及需要额外内存空间来存储另一份数组副本的其他排序算法。

### 数据类型

数据模版适用于任何**实现了 Comparable 接口的数据类型**。Java 中封装数字的类型 Integer 和 Double，以及 String 和其他许多高级数据类型（如 File 和 URL）都实现了 Comparable 接口。

而在**创建自己的数据类型**时，只要实现 Comparable 接口就能保证用例代码可以将其排序。要做到这一点，只需要实现一个`compareTo()`方法来定义目标类型对象的**自然次序**。

## 选择排序

最简单的排序算法，不断选择剩余元素之中的最小者，与遍历到的当前元素交换位置。

```cpp
/*
参数1：arr。一维数组的首地址
参数2：length。一维数组的元素个数（长度）
*/
void SelectSort(int* arr, int length)
{
	for (int i = 1; i <= length; ++i)
	{
		int min = i;
		for (int j = i + 1; j <= length; ++j)
		{
			if (arr[j] < arr[min]) min = j;
		}
		//如果从当前元素i之后的序列中找到了一个比i大的元素，交换他俩的位置
		if (min != i)
		{
			int temp = arr[min];
			arr[min] = arr[i];
			arr[i] = temp;
		}
	}
}
```

对于长度为 N 的数组，选择排序需要大约 N^2/2 次比较和 N 次交换。

选择排序的特点：

* 运行时间和输入无关：一个已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间一样长；
* 数据移动是最少的：每次交换都会改变两个数组元素的值，因此选择排序用了 N 次交换——交换次数和数组的大小是**线性**关系。其他算法大多都是线性对数或是平方级别。

## 插入排序

### 基本思想

插入排序的思想如同它的名字一般：“插入”。我们可以将待排序的无序序列的首元素看作是一组有序序列，序列元素个数为1，其后是一段无序序列。每次取出无序序列的第一个元素，也即有序序列末尾元素的下一个元素，将该元素从后往前，依次和有序序列中的元素比较。被比较的有序元素如果大于该元素，有序元素向后移动一位，直到找到第一个小于该元素值（*升序*）的元素，将无序元素插入到该有序序列元素的下一个位置。
重复上面的过程，直到无序序列中没有元素，序列就被排序完成啦！是不是很简单呀？

### 算法流程

例如，有一个待排序的无序序列 {28,44,13,22,19,11,49,16,16,42 }
该序列通过插入排序得到有序序列的动画效果如下：

![插入排序算法动画](https://img-blog.csdnimg.cn/20210307224044111.gif#pic_center)

> 动画来源：[算法可视化网站](https://visualgo.net/zh)

看完这个动画，结合文章中对该算法的基本思想描述，能否自己写出插入排序的代码？

### 代码实现

- 语言：C++
- 序列存储结构：一维数组

在阅读这段代码之前，我先补充一个知识：数组初始化时，第0个位置不存放无序元素，该位置是用作插入排序的**哨兵位置**。引入哨兵的好处在于**减少判断循环边界位置的比较次数，提高程序运行速度**，话不多说，上代码：

~~~cpp
/*
参数1：arr。一维数组的首地址
参数2：length。一维数组的元素个数（长度）
*/
void InsertSort(int* arr, int length)
{
	for (int i = 2; i <= length; ++i)
	{
		//设置哨兵
		arr[0] = arr[i];
		int j = i - 1;
		for (; arr[j] > arr[0]; --j)
		{
			arr[j + 1] = arr[j];
		}
		arr[j + 1] = arr[0];
	}
}
~~~

### 总结

- 算法时间复杂度：$O(n^2)$
- 算法空间复杂度：$O(1)$
- 算法是否稳定：
  *算法稳定性指的是序列通过该算法排序后，比较值相同（key）的两个元素相对顺序是否会发生改变*
- 算法适用范围：由于插入排序算法简单，高效，且具有稳定性，通常应用于序列元素较少的排序场合。



## 希尔排序

**希尔排序**是一种基于插入排序的快速的排序算法，为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。

**思想**：使数组中任意间隔为 h 的元素都是有序的。这样的数组被称为 **h 有序数组**。换句话说，一个 h 有序数组就是 h 个互相独立的有序数组编织在一起的一个数组。

![2017-12-16 21 04 05](https://algs4.cs.princeton.edu/21elementary/images/h-sorted.png)

希尔排序更高效的原因是它权衡了子数组的规模和有序性。排序之初各个子数组都很短，排序之后的子数组都是部分有序的，这两种情况都很适合插入排序。

使用递增序列 1，4，13，40，121，364...的希尔排序所需的比较次数不会超出 N 的若干倍乘以递增序列的长度。

希尔排序的代码量很小，且不需要使用额外的内存空间。对于中等大小的数组，它的运行时间是可以接受的。

```cpp
/*
参数1：arr。一维数组的首地址
参数2：flag。确定间隔的递减序列数组首地址
参数3：length1。一维数组的元素个数（长度）
参数4：length2。递减数组的元素个数（长度）

flag间隔数组的取值是希尔排序的一个难点之一，该数组没有唯一取值方式。
如果待排序序列数量很大（>1e4），flag数组的建议值为int flag[] = { 121,40,13,4,1 };
*/
void ShellSort(int* arr, int* flag, int length1, int length2)
{
	for (int p = 0; p < length2; ++p)
	{
		int h = flag[p];//间隔
		//接下来是间隔为h的插入排序
		for (int i = h + 1; i <= length1; ++i)
		{
			arr[0] = arr[i];//哨兵位
			int j = i - h;
			for (; j > 0 && arr[j] > arr[0]; j -= h)
			{
				arr[j + h] = arr[j];
			}
			arr[j + h] = arr[0];
		}
	}
}
```

