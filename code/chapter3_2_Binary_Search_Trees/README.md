# 3.2 二叉查找树

**定义**：一棵**二叉查找树（BST，或二叉搜索树）**是一棵二叉树，其中每个结点都含有一个 Comparable 的键（以及相关联的值）且每个结点的键都大于其左子树中的任意结点的键而小于右子树的任意结点的键。

## 基本实现

### 数据表示

二叉查找树上的一个结点，**左链接**指向一棵**小于**该结点的所有键组成的二叉查找树，**右链接**指向一棵由**大于**该结点的所有键组成的二叉查找树。

### 查找

在二叉查找树中查找一个键的递归算法：如果树是空的，则查找未命中；如果被查找的键和根结点的键相等，查找命中，否则我们就（递归地）在适当的子树中继续查找。如果被查找的键较小就选择左子树，较大则选择右子树。

### 删除*

对于删除一个拥有两个子结点的情况，在删除结点 x 后用它的**后继结点**填补它的位置。因为 x 有一个右子结点，因此它的后继结点就是**其右子树中的最小结点**。这样的替换仍然能保证树的有序性，因为 x.key 和它的后继结点的键之间不存在其他的键。

用 4 个简单的步骤能够完成将 x 替换为它的后继结点的任务：

1. 将指向即将被删除的结点的链接保存为 t；
2. 将 x 指向它的后继结点`min(t.right)`；
3. 将 x 的**右链接**（原本指向一棵所有结点都大于 x.key 的二叉查找树）指向`deleteMin(t.right)`，也就是在删除后所有结点仍然大于 x.key 的子二叉查找树；
4. 将 x 的**左链接**（本为空）设为 t.left（其下所有的键都小于被删除的结点和它的后继结点）。

对于某些大规模的实际应用，这种方法可能会有一点性能上的问题。

## 分析

使用二叉查找树的算法的运行时间取决于树的形状，而树的形状又取决于键被插入的先后顺序。

* **最好**情况：一棵含有 N 个结点的树是完全平衡的，每条空链接和根结点的距离都为 ~lgN。
* **最坏**情况：搜索路径上可能有 N 个结点。

在由 N 个随机键构造的二叉查找树中，查找命中平均所需的比较次数为 ~2lnN（约 1.39 lgN）。

在由 N 个随机键构造的二叉查找树中插入操作和查找未命中平均所需的比较次数为 ~2lnN（约 1.39 lgN）。

## 简单的符号表实现的成本总结

| 算法（数据结构） | N 次插入后最坏情况下的查找成本 | N 次插入后最坏情况下的插入成本 | N 次随机插入后平均情况下的查找成本 | N 次随机插入后平均情况下的查找成本 | 是否高效支持有序性相关的操作
| :----: | :----: | :----: | :----: | :----: | :----: |
| 顺序查找（无序链表） | N | N | N/2 | N | 否
| 二分查找（有序数组） | lgN | 2N | lgN | N | 是
| 二叉树查找（二叉查找树） | N | N | 1.39lgN | 1.39lgN | 是

随机键构造的二叉查找树的平均高度为树中结点数的对数级别。而对于不随机的构造树的键，有**平衡二叉查找树**来保证无论键的插入顺序如何，树的高度都将是总键数的对数。