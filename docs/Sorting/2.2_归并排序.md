# 2.2 归并排序

**归并**：将两个有序的数组归并成一个更大的有序数组。

归并排序能保证将任意长度为 N 的数组排序所需时间和 NlogN 成正比；但主要缺点是所需的额外空间和 N 成正比。

每一次归并将涉及的所有元素复制到一个辅助数组中，再把归并的结果放回原数组中。

## 自顶向下的归并排序

归并算法是算法设计中**分治思想**的典型应用。

**比较次数**：对于长度为 N 的任意数组，自顶向下的归并排序需要 1/2NlgN 至 NlgN 次比较。

注：N = 2 ^ n  ==>  n = lgN

**访问数组次数**：对于长度为 N 的任意数组，自顶向下的归并排序最多需要访问数组 6NlgN 次。

### 性能优化点

#### 对小规模子数组使用插入排序

**递归**会使**小规模问题**中方法的调用过于频繁，所以改进对它们的处理方法就能改进整个算法。

对排序来说，插入排序（或选择排序）可能在小数组上比归并排序更快。

## 自底向上的归并排序

对于长度为 N 的任意数组，自底向上的归并排序需要 1/2NlgN 至 NlgN 次比较，最多需要访问数组 6NlgN 次。

自底向上的归并排序比较适合用**链表**组织的数据。将链表按大小为 1 的子链表进行排序，然后是大小为 2 的子链表，然后是大小为 4 的子链表等。这种方法只需要重新组织链表链接就能将链表**原地**排序。

## 排序算法的复杂度

**命题**：没有任何基于比较的算法能够保证使用少于 lg(N!) ~ NlgN 次比较将长度为 N 的数组排序。

**证明**：

假设没有重复的主键（因为这是所有排序算法的必要需求）。N 个不同的主键会有 N! 种不同的排列。

任何基于比较的排序算法都对应着一颗高 h 的比较树，其中`N! <= 叶子结点的数量 <= 2^h`。h 的值就是最坏情况下的比较次数，因此对不等式的两边取对数可得到任意算法的比较次数至少是 lgN!。

根据斯特灵公式可得 lgN! ~ NlgN。

注：斯特灵公式：`lgN! = lg1 + lg2 + ... + lgN ~ NlgN`

归并排序是一种渐进最优的基于比较排序的算法。也就是说，归并排序在最坏情况下的比较次数和任意基于比较的排序算法所需的最少比较次数都是 ~NlgN。


