# 2.1 初级排序算法

## 游戏规则

### 排序算法类的模板

```java
public class Example {
    public static void sort(Comparable[] a) {
        // 各类排序算法
    }

    private static boolean less(Comparable v, Comparable w) {
        // 对元素进行比较
        return v.compareTo(w) < 0;
    }

    private static void exch(Comparable[] a, int i, int j) {
        // 将元素交换位置
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }

    private static void show(Comparable[] a) {
        // 在单行中打印数组
        for(int i = 0; i < a.length; i++)
            StdOut.print(a[i] + " ");
        StdOut.println();
    }

    public static boolean isSorted(Comparable[] a) {
        // 测试数组元素是否有序
        for(int i = 1; i < a.length; i++)
            if(less(a[i], a[i - 1]))
                return false;
        return true;
    }

    public static void main(String[] args) {
        // 从标准输入读取字符串，将它们排序并输出
        String[] a = In.readStrings();
        sort(a);
        assert isSorted(a);
        show(a);
    }
}
```

### 验证

尽管一般都会测试代码并从数学上证明算法的正确性，但在实现每个排序算法时在测试代码中添加一条`assert isSorted(a);`来确认排序后数组元素都是有序的。

### 运行时间

**排序成本模型**：在研究排序算法时，我们需要计算**比较**和**交换**的数量。对于不交换元素的算法，我们会计算**访问数组的次数**。

### 额外的内存时间

排序算法可以分为两类：除了函数调用所需的栈和固定数目的实例变量之外无需额外内存的**原地排序算法**，以及需要额外内存空间来存储另一份数组副本的其他排序算法。

### 数据类型

数据模版适用于任何**实现了 Comparable 接口的数据类型**。Java 中封装数字的类型 Integer 和 Double，以及 String 和其他许多高级数据类型（如 File 和 URL）都实现了 Comparable 接口。

而在**创建自己的数据类型**时，只要实现 Comparable 接口就能保证用例代码可以将其排序。要做到这一点，只需要实现一个`compareTo()`方法来定义目标类型对象的**自然次序**。

## 选择排序

最简单的排序算法，不断选择剩余元素之中的最小者，与遍历到的当前元素交换位置。

```java
public static void sort(Comparable[] a) {
    // 将 a[] 按升序排列
    int N = a.length;
    for(int i = 0 ; i < N; i++) {
        // 将 a[i] 和 a[i...N]中最小的元素交换
        int min = i;    // 最小元素的索引
        for(int j = i+1; j < N; j++)
            if(less(a[j], a[min]))
                min = j;
        exch(a, i, min);
    }
}
```

对于长度为 N 的数组，选择排序需要大约 N^2/2 次比较和 N 次交换。

选择排序的特点：

* 运行时间和输入无关：一个已经有序的数组或是主键全部相等的数组和一个元素随机排列的数组所用的排序时间一样长；
* 数据移动是最少的：每次交换都会改变两个数组元素的值，因此选择排序用了 N 次交换——交换次数和数组的大小是**线性**关系。其他算法大多都是线性对数或是平方级别。

## 插入排序

每次将正在遍历的元素插入到其他已经有序的元素中的适当位置。与选择排序一样，当前索引左边的所有元素都是有序的，但它们的最终位置还不确定。为了给更小的元素腾出空间，它们可能会向右移动。当索引到达数组的右端时，数组排序就完成了。

```java
public static void sort(Comparable[] a) {
    // 将 a[] 按升序排列
    int N = a.length;
    for(int i = 1; i < N; i++) {
        // 将 a[i] 插入到 a[i-1]、a[i-2]、a[i-3]...之中   
        /** 有改进空间，见练习 2.1.25  */
        for(int j = i; j > 0 && less(a[j], a[j-1]); j--)
            exch(a, j, j-1);
    }
}
```

对于随机排列的长度为 N 且主键不重复的数组，平均情况下插入排序需要 ~N^2/4 次比较以及 ~N^2/4 次交换。最坏情况下需要 ~N^2/2 次比较和 ~N^2/2 次交换，最好情况下需要 N-1 次比较和 0 次交换。

插入排序所需的时间取决于输入中元素的初始顺序。因此，插入排序对于**部分有序**的数组十分高效，也很适应小规模数组。

选择排序和插入排序的可视化对比：

![选择排序和插入排序的可视化对比](https://algs4.cs.princeton.edu/21elementary/images/bars.png)

## 希尔排序

**希尔排序**是一种基于插入排序的快速的排序算法，为了加快速度简单地改进了插入排序，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。

**思想**：使数组中任意间隔为 h 的元素都是有序的。这样的数组被称为 **h 有序数组**。换句话说，一个 h 有序数组就是 h 个互相独立的有序数组编织在一起的一个数组。

![2017-12-16 21 04 05](https://algs4.cs.princeton.edu/21elementary/images/h-sorted.png)

希尔排序更高效的原因是它权衡了子数组的规模和有序性。排序之初各个子数组都很短，排序之后的子数组都是部分有序的，这两种情况都很适合插入排序。

使用递增序列 1，4，13，40，121，364...的希尔排序所需的比较次数不会超出 N 的若干倍乘以递增序列的长度。

希尔排序的代码量很小，且不需要使用额外的内存空间。对于中等大小的数组，它的运行时间是可以接受的。

```java
public static void sort(Comparable[] a) {
    // 将 a[] 按升序排列
    int N = a.length;
    int h = 1;
    while(h < N / 3)
        h = 3 * h + 1;    // 1, 4, 13, 40, 121, 364, 1093, ...
    while(h >= 1) {
        // 将数组变为 h 有序
        for(int i = h; i < N; i++) {
            // 将 a[i] 插入到 a[i-h]，a[i-2*h]，a[i-3*h]... 之中
            for(int j = i; j >= h && less(a[j], a[j -h]); j -= h)
                exch(a, j, j-h);
        }
        h /= 3;
    }
}
```



