# 2.4 优先队列

优先队列最重要的操作就是**插入元素**和**删除最大元素**。

**应用场景：**在某些数据处理的场合，**总数据量太大**（可以认为输入是无限的），无法排序（甚至无法全部装进内存）。如果将每个新的输入和已知的 M 个最大（或最小）元素比较，除非 M 较小，否则这种比较的代价会非常高昂。如果有了**优先队列**，就只用一个能存储 M 个元素的队列即可。

## 初级实现

* 数组实现（无序）：惰性方法，仅在必要的时候找出最大元素；
* 数组实现（有序）：积极方法：在插入时就保持列表有序，使后续操作更高效；
* 链表表示法

在上述优先队列的初级实现中，**删除最大元素**和**插入元素**这两个操作之一在最坏情况下需要**线性**时间来完成。

| 数据结构 | 插入元素 | 删除最大元素 |
| :----: | :----: | :----: |
| 有序数组 | N | 1 |
| 无序数组 | 1 | N |
| 堆 | logN | logN |
| 理想情况 | 1 | 1 |

## 堆的定义

当一棵二叉树的每个结点都**大于等于**它的两个子结点时，它被称为**堆有序**。

根结点是堆有序的二叉树中的最大结点。

### 二叉堆表示法

如果使用指针来表示堆有序的二叉树，那么每个元素都需要**三个指针**来找到它的上下结点。

但使用完全二叉树，只需要数组而不需要指针就可以表示，十分方便。具体方法是将二叉树的结点按照**层级顺序**放入数组中。

**定义**：**二叉堆**（后文简称为堆）是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存（不使用数组的第一个位置）。

在一个堆中，位置`k`的结点的父结点的位置为`⌊k/2⌋`，子结点位置分别为`2k`和`2k+1`。

**高性能的原因**：利用在数组中无需指针即可沿树上下移动的便利。

注：完全二叉树：除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点。

一棵大小为 N 的完全二叉树的高度为`⌊lgN⌋`。

## 堆的算法

**堆的有序化**：打破堆的状态，然后再遍历堆并按照要求将堆的状态恢复。

**插入元素**时，将新元素加到数组末尾，增加堆的大小并让这个新元素上浮到合适的位置。

**删除最大元素**时，从数组顶端删去最大的元素并将数组的最后一个元素放到顶端，减小堆的大小并让这个元素下沉到合适的位置。

这样，**删除最大元素**和**插入元素**这两个操作的用时和队列的大小仅成**对数**关系。对于一个含有 N 个元素的基于堆的优先队列，插入元素操作只需不超过 (lgN+1) 次比较，删除最大元素的操作需要不超过 2lgN 次比较。

## 堆排序

用下沉操作由 N 个元素构造堆只需少于 2N 次比较以及少于 N 次交换。

将 N 个元素排序，堆排序只需少于 (2NlgN+2N) 次比较（以及一半次数的交换）。

### 特点

**堆排序的优点**：所知的唯一能够同时最优地利用空间和时间的方法；

**堆排序的缺点**：**无法利用缓存**。数组元素很少和相邻的其他元素进行比较，因此缓存未命中的次数要远远高于大多数比较都在相邻元素间进行的算法（如快速排序、归并排序、希尔排序）。

**堆排序的使用场景**：当空间十分紧张时（例如在嵌入式系统或低成本的移动设备中）很流行，但现代系统的许多应用很少使用它。