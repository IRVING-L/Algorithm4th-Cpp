# 4.4 最短路径

本节研究最短路径问题：找到从一个顶点到达另一个顶点的**成本最小**的路径。

## 最短路径的性质

### 需要解决的问题

* 并不是所有顶点都是可达的：为了简化问题，约定图都是强连通的（每个顶点从另外任意一个顶点都是可达的）。
* 负权重会使问题更复杂：经典 Bellman-Ford 算法可以解决。
* 最短路径一般都是简单的：我们的算法会忽略构成环的零权重边，因此找到的最短路径都不会含有环。
* 可能存在平行边和自环：平行边中权重最小者才会被选中，权重为零的自环会被忽略。

### 最短路径树（SPT）

**定义**：给定一幅加权有向图和一个顶点 s，以 s 为起点的一棵**最短路径树**是图的一幅子图，它包含 s 和从 s 可达的所有顶点。这棵有向树的根结点为 s，树的每条路径都是有向图中的一条最短路径。

## 加权有向图的数据结构

### 最短路径的数据结构

表示最短路径所需的数据结构：

* **最短路径树中的边**：和深度优先搜索、广度优先搜索和 Prim 算法一样，使用一个**由顶点索引的 DirectedEdge 对象的父链接数组 edgeTo[]**，其中 edgeTo[v] 的值为树中连接 v 和它的父结点的边（也是从 s 到 v 的最短路径上的最后一条边）。
* **到达起点的距离**：使用一个**由顶点索引的数组 distTo[]**，其中 distTo[v] 为从 s 到 v 的已知最短路径的长度。

约定（s 是寻找的起点）：

* edgeTo[s] 的值为 null，distTo[s] 的值为 0。
* 从起点到不可达的顶点的距离均为`Double.POSITIVE_INFINITY`。

### 边的松弛

**放松**边 v->w 意味着检查从 s 到 w 的最短路径是否是先从 s 到 v，然后再由 v 到 w。如果是，则根据这个情况更新数据结构中的内容。

边的放松操作之后可能出现两种情况：

* 边失效（`distTo[w] <= distTo[v] + e.weight()`）；
* v->w 就是到达 w 的最短路径，更新 edgeTo[w] 和 distTo[w]（这可能会使另一些边失效，但也有可能产生一些新的有效边）。

实际上，实现会放松从一个给定顶点指出的所有边。

## 最短路径算法的理论基础


## Dijkstra 算法

Dijkstra 算法能够解决**边权重非负**的加权有向图的单起点最短路径问题。

思想：**每次添加离起点最近的非树顶点**。

### 数据结构

### 开销

在一幅含有 V 个顶点和 E 条边的加权有向图中，使用 Dijkstra 算法计算根结点为给定起点的最短路径树所需的**空间与 E 成正比**，所需的**时间与 ElogE 成正比（最坏情况）**。

### 与 Prim 算法的比较