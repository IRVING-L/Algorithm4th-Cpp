# 4.3 最小生成树

本节研究最小生成树问题：给定一幅**加权无向图**，找到它的一棵最小生成树。

## 术语表

* 图的**生成树**：它的一棵含有其所有顶点的无环连通子图。
* 一幅**加权图**的**最小生成树（MST）**：它的一棵权值（树中所有边的权值之和）最小的生成树。

## 约定

* 只考虑连通性。
* 边的权重不一定表示距离。
* 边的权重可能是 0 或者负数。
* 所有边的权重都各不相同。

## 原理

### 切分定理

#### 原理

* 用一条边连接树中的任意两个顶点都会产生一个新的环；
* 从树中删去一条边将会得到两棵独立的树。

#### 定义

* 图的一种**切分**：将图的所有顶点分为两个非空且不重叠的两个集合；
* **横切边**：一条连接两个属于不同集合的顶点的边。

#### 命题（切分定理）

在一幅加权图中，给定任意的切分，它的**横切边中的权重最小者**必然属于图的最小生成树。

#### 证明

反证法。详见 p392。

### 最小生成树的贪心算法

#### 命题

下面这种方法会将含有 V 个顶点的任意加权连通图中属于最小生成树的边标记为黑色：

初始状态下所有边均为灰色，找到一种切分，它产生的横切边均不为黑色。将它权重最小的横切边标记为黑色。反复，直到标记了 V-1 条黑色边为止。

## Prim 算法

每一步都会为一棵生长中的树添加一条边。一开始这棵树只有一个顶点，然后会向它添加 V-1 条边，每次总是将下一条**连接树中的顶点与不在树中的顶点且权重最小的边**加入树中（即由树中的顶点所定义的切分中的一条横切边）。

### 延时实现

Prim 算法的延时实现使用了一条优先队列来保存所有的横切边、一个由顶点索引的数组来标记树的顶点以及一条队列来保存最小生成树的边。这种延时实现会在优先队列中**保留**失效的边。

#### 开销

Prim 算法的延时实现计算一幅含有 V 个顶点和 E 条边的连通加权无向图的最小生成树所需的**空间与 E 成正比**，所需的**时间与 ElogE 成正比（最坏情况）**。

**证明**：

优先队列中最多可能有 E 条边，这就是空间需求的上限。

算法的瓶颈在于优先队列的`insert()`和`delMin()`方法中比较边的权重的次数。在最坏情况下，一次插入的成本为 ~lgE，删除最小元素的成本为 ~2lgE。因为最多只能插入 E 条边，删除 E 次最小元素，因此所需的时间与 ElogE 成正比（最坏情况）。

### 即时实现

我们感兴趣的只是连接树顶点和非树顶点中**权重最小**的边。当我们将顶点 v 添加到树中时，对于每个非树顶点 w 产生的变化只可能使得 w 到最小生成树的距离更近。因此，我们只需要在优先队列中保存每个非树顶点 w 的一条边：**将它与树中顶点连接起来的权重最小的那条边**。

Prim 算法的即时实现将有效的横切边保存在了一条索引优先队列中。

#### 开销

Prim 算法的即时实现计算一幅含有 V 个顶点和 E 条边的连通加权无向图的最小生成树所需的**空间与 V 成正比**，所需的**时间与 ElogV 成正比（最坏情况）**。

**证明**：

因为优先队列中的顶点树最多为 V，且使用了三条由顶点索引的数组，所以所需的空间的上限和 V 成正比。

算法会进行 V 次插入操作，V 次删除最小元素的操作和（在最坏情况下）E 次改变优先级的操作。已知在基于堆实现的索引优先队列中所有这些操作的增长数量级为 logV，所以将所有这些加起来可知算法所需时间和 ElogV 成正比。

## Kruskal 算法

按照边的权重顺序（从小到大）处理它们，将边加入最小生成树中，**加入的边不会与已经加入的边构成环**，直到树中含有 V-1 条边为止。我们从一片由 V 棵单顶点的树构成的森林开始并不断将两颗树合并（用可以找到的最短边），直到只剩下一棵树，它就是最小生成树。

#### 开销

Kruskal 算法的计算一幅含有 V 个顶点和 E 条边的连通加权无向图的最小生成树所需的**空间与 E 成正比**，所需的**时间与 ElogE 成正比（最坏情况）**。

**证明**：

算法的实现在构造函数中使用所有边初始化优先队列，成本最多为 E 次比较。

优先队列构造完成后，其余的部分和 Prim 算法完全相同。优先队列中最多可能含有 E 条边，即所需的空间的上限。每次操作的成本最多为 2lgE 次比较，这就是时间上限的由来。

## 总结与展望

各种最小生成树算法 V 个顶点 E 条边，最坏情况下的增长数量级：

算法 | 空间 | 时间
:----------- | :-----------: | :----------- 
[延时的 Prim 算法](https://github.com/bighuang624/Algorithms-notes/blob/master/code/chapter4_3_Minimum_Spanning_Tree/LazyPrimMST.java)        | E | ElogE    
[即时的 Prim 算法](https://github.com/bighuang624/Algorithms-notes/blob/master/code/chapter4_3_Minimum_Spanning_Tree/PrimMST.java)         | V | ElogV       
[Kruskal](https://github.com/bighuang624/Algorithms-notes/blob/master/code/chapter4_3_Minimum_Spanning_Tree/KruskalMST.java)         | E | ElogE     
Fredman-Tarjan         | V | E+VlogV 
Chazelle         | V | 非常接近但还没有达到 E    
理想情况         | V | E?     

一方面，目前还没有理论能够证明，不存在能在线性时间内得到任意图的最小生成树的算法；另一方面，发明能够在线性时间内计算稀疏图的最小生成树的算法仍然没有进展。
